need to format cointegration test for 90 days rolling instead of entire dataset

--> then we upload to db with same test date for each pair


epsilon test:
    -->calculate z-score based on 90 day rolling mean and std
    --> find optimal z score entry and exits based on historical data
    --> each entry and exit's z score is between +-2 and +-1 and goes to +-1 and 0 and is tested in increments of 0.1
    --> calculate the reversion success rate based on z-scores to find optimal z-score entry and exit for trading pair
    --store these in DB for a trading pair


trade_window table
    id primary key INT
    ticker_id1 INT
    ticker_id2 INT
    optimal_zscore REAL
    optimal_reversions INT
    optimal_reversion_success INT
    start_date DATE
    end_date DATE
    trade_type BOOL
    unique constraint tickerid_1 ticker_id2 start_date end_date








--Options




(DONE)
Based on ticker and date from trade window table find option tickers for range based on close price

    todo:

    --S(DONE) 
        underlying close/mid price
        

    --K (DONE)
        strike price option ticker

    --T (PARTIAL)
        time to expiry:  purchase date-expiry/365 

    --r (DONE)
        need risk free rate for securities
        U.S. Treasury constant‑maturity series (FRED code DGS1MO, DGS3MO, DTB3)	Manual: download CSV from https://fred.stlouisfed.org.
        Script: fredapi → fred.get_series('DGS1MO', '2024‑12‑17') / 100.
    --q (DONE)
        need dividend yeilds for underlying tickers

    --P_obs (ALMOST)
        (bid+ask) /2

     --tt (DONE)
        +1 call // -1 put


Option Pricing Formula solving for IV:

----Solve for σ (implied volatility) that makes Black-Scholes price equal P_obs:
DONE!!
f(σ) = {
    For Call: Se^(-qT)Φ(d₁) - Ke^(-rT)Φ(d₂) - P_obs
    For Put:  Ke^(-rT)Φ(-d₂) - Se^(-qT)Φ(-d₁) - P_obs
}

Where:
- S: Current stock price
- K: Strike price
- r: Risk-free interest rate
- q: Dividend yield
- T: Time to expiration
- σ: Volatility (this is what we solve for)
- Φ: Standard normal cumulative distribution function
- P_obs: Observed option price

And d₁, d₂ are given by:

d₁ = [ln(S/K) + (r - q + 0.5σ²)T] / (σ√T)
d₂ = d₁ - σ√T

Note: We use numerical methods (e.g., Newton-Raphson) to solve for σ since 
the equation cannot be solved analytically.
    use brent if fails


-----Option Greeks Formulas:

(DONE) Δ (Delta) = cp*e^(-qT) * Φ(cp*d₁)

Γ (Gamma) = Se^(-qT) * φ(d₁) / (S*σ*√T)

Θ (Theta) = -(S*σ*e^(-qT) * φ(d₁))/(2*√T) - cp*(r*K*e^(-rT)*Φ(cp*d₂) - q*S*e^(-qT)*Φ(cp*d₁))/365

Vega = S*e^(-qT) * φ(d₁) * √T/100

Where:
- S: Stock price
- K: Strike price
- r: Risk-free rate
- q: Dividend yield
- T: Time to expiration
- σ: Volatility
- φ: Standard normal probability density function
- Φ: Standard normal cumulative distribution function
- cp: +1 for calls, -1 for puts


MonteCarlo simulation
    --> based on a unique pair A and B find other historical points
    



Program Logic Outline

1. Data Ingestion & Preprocessing

Universe filtering: select tickers with ≥2 years of historical daily price data (≈504 trading days).

Load prices:

Daily OHLCV for past 5 years (≈1,260 days).

15‑minute OHLCV bars for intraday back‑test days.

Compute log prices and store rolling statistics (already in place: 30‑day, 90‑day means/std).

2. Initial Pair Screening

Option A: Correlation filter (optional):

Compute daily Pearson ρ over 504-day window for all pairs (5,718×5,717/2 ≈16M).

Retain pairs with |ρ| ≥ 0.80.

Option B: Skip correlation if using GPU-accelerated cointegration (next step) directly.

3. Rolling Daily Cointegration Fit
For each trading day d in [start + 90, end]:

Window: last 90 daily log-prices for each candidate pair.

Compute α, β via closed‑form OLS on GPU (Cov/Var or vectorized CuPy).

Compute residuals: ε_i = lnP2_i – α – β·lnP1_i.

Compute μ(d), σ(d) of those 90 residuals.

Store (daily_coint_params): (date=d, ticker1, ticker2, α, β, μ, σ).

4. Intraday 15‑min Z‑Score Scan
For each day d:

Fetch (α_d, β_d, μ_d, σ_d) for all pairs.

Load 15‑min log-prices for that day: lnP1[t_i], lnP2[t_i], nanosecond stamps.

GPU batch compute:

ε[t_i,p] = lnP2 – α_d – β_d·lnP1

z[t_i,p] = (ε – μ_d)/σ_d

Detect triggers: find first bar index i where |z| ≥ entry_z.

Record trade event with precise timestamp (bar_date, bar_time, nanoseconds).

5. Option Leg & P_obs Retrieval
For each trade event:

Query option chain snapshot at entry as_of = entry_t_ms.

Filter strikes ±15%, expiries 20–45 days.

Fetch P_obs:

/v3/trades/{optTicker}?timestamp.gte=entry_ns&timestamp.lt=entry_ns+window

Compute implied vol via BS inversion, then derive Greeks.

Trade decision: check greeks vs strategy rules.

6. Exit & PnL

Exit logic: use same day’s z-score exit threshold or time/stop rule.

Fetch P_exit with nanosecond stamp at exit bar.

Calculate PnL = (P_exit – P_entry)×100 contracts.

7. Monte Carlo Stress Tests

Perturb underlying log-prices by ±k·σ (or bootstrap daily returns).

Resample risk-free rates/dividends for each scenario.

Re-run option-pricing & PnL 1,000× in parallel (GPU/Numba) to build distribution.

8. Performance Optimizations

GPU acceleration: cointegration α/β, ε/z, Monte Carlo.

Pruning: correlation + sector clustering.

Parallelism: 16‑core CPU for I/O & DB writes.

Caching: risk-free/dividend lookups.

9. End‑to‑End Backtest Flow

Ingest & preprocess prices

Daily rolling cointegration → store params

Daily intraday z-scan → record events

Option P_obs & Greeks → generate trades

Exit & compute PnL → store results

Monte Carlo portfolio analysis

This outline ensures each day uses its own α/β/μ/σ, captures intraday timing, and leverages GPU/parallelism for scale.